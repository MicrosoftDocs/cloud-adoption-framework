# Deploy and manage Azure landing zones with infrastructure as code

Infrastructure as Code (IaC) provides a programmatic approach to deploying and managing your Azure resources. IaC transforms infrastructure provisioning from manual, error-prone processes into automated, consistent, and repeatable deployments. This approach ensures your Azure environment remains aligned with organizational standards while enabling rapid scaling and reliable configuration management.

Organizations use IaC to eliminate configuration drift, reduce deployment errors, and establish version control for their entire Azure infrastructure. The programmatic nature of IaC enables teams to track changes, roll back deployments, and maintain consistent environments across development, testing, and production.

## Select your infrastructure as code tools

The choice between Azure-native and third-party tools affects your deployment capabilities, support timelines, and integration patterns with your existing technology stack.

1. **Choose Azure-native tools for Azure-first organizations.** Use [Azure Resource Manager templates](/azure/azure-resource-manager/templates/overview) or [Bicep](/azure/azure-resource-manager/bicep/overview) when your organization focuses solely on Azure services. Azure-native tools typically surface new Azure features, including preview services and the latest API versions, earlier than third-party tools. These tools integrate with [Azure DevOps](/azure/devops/pipelines/), [GitHub Actions](/azure/azure-resource-manager/bicep/deploy-github-actions), and other Microsoft development tools. Organizations with existing ARM template experience can migrate to Bicep for improved syntax while maintaining deployment compatibility.

    - **Select Bicep over ARM templates for new Azure deployments.** [Bicep provides the same capabilities as ARM templates with simplified syntax](/azure/azure-resource-manager/bicep/overview) that's easier to read, write, and maintain. Bicep compiles to ARM templates during deployment, ensuring full compatibility with existing Azure Resource Manager processes. The language includes features like type safety, IntelliSense support, and improved error messages that accelerate development and reduce deployment errors.

    - **Understand tool-specific considerations for configuration management.** Different tools handle configuration drift and out-of-band changes differently. [Bicep deployments are more friendly to out-of-band changes](/azure/developer/terraform/comparing-terraform-and-bicep#out-of-band-changes). Bicep doesn’t block deployments due to drift, but it also doesn’t detect or reconcile drift unless combined with tools like Azure Policy. Terraform requires you to import out-of-band changes into the state file and update the configuration code. Choose your tool based on your team's change management practices and the likelihood of manual modifications to deployed resources.

2. **Choose Terraform for multi-cloud or existing Terraform environments.** Use [Terraform](/azure/developer/terraform/overview) when your organization operates across multiple cloud providers like AWS or Google Cloud, or when you have existing Terraform expertise and modules. While Terraform provides excellent Azure support through the AzureRM provider, new Azure features take additional time to become available compared to Azure-native tools. The [Azure landing zones Terraform module](../landing-zone/deploy-landing-zones-with-terraform.md) provides enterprise-ready templates for deploying foundational infrastructure.

3. **Use imperative tools for specific automation scenarios.** While declarative IaC tools like Bicep and Terraform should be your primary approach, tools like [Azure CLI](/cli/azure/) and [Azure PowerShell](/powershell/azure/) serve specific purposes. Use these imperative tools for custom automation scripts, complex deployment workflows that require conditional logic, or integration with existing automation systems that require procedural control. These tools complement your declarative templates by providing flexible scripting capabilities for specialized scenarios.

## Implement modular infrastructure patterns

Modular design enables code reuse, simplifies maintenance, and allows teams to share proven patterns across multiple deployments and workloads. One of the goals of using code to deploy infrastructure is to avoid duplicating work or creating multiple templates for the same or similar purposes. Infrastructure modules should be reusable and flexible and should have a clear purpose.

1. **Create reusable modules for logically grouped resources.** Develop [Bicep modules](/azure/azure-resource-manager/bicep/modules) or [Terraform modules](/azure/developer/terraform/overview) that break complex templates into smaller, more manageable sets of code. Each module should focus on a specific task and contain resources meant to be deployed together. For example, when you define an Azure function, you typically deploy the application, a hosting plan, and a storage account as a logical grouping. Design modules with parameters to accept values from calling templates, output values to return results, and resources that define the infrastructure objects the module manages.

2. **Design Bicep modules for multiple related resources.** Bicep allows you to create and call modules that can be consumed from any other Bicep template. A high quality Bicep module should define multiple related resources that form a logical grouping. Bicep modules commonly use parameters to accept values from a calling module, output values to return results to a calling module, and resources to define one or more infrastructure objects for a module to manage.

3. **Structure Terraform modules with clear configuration patterns.** Each Terraform configuration has at least one module, known as its root module, consisting of resources defined in `.tf` files in your main working directory. Modules can call other modules and be called multiple times within the same configuration or from different configurations. Terraform modules commonly use input variables to accept values from a calling module, output values to return results to a calling module, and resources to define one or more infrastructure objects for a module to manage.

4. **Implement proper module testing and validation.** Test modules in isolation before integrating them into larger deployments. Use tools like [ARM template test toolkit](/azure/azure-resource-manager/templates/test-toolkit) and [Terratest](https://terratest.gruntwork.io/) for Terraform modules. Establish validation processes that verify module functionality, security configurations, and compliance requirements before publishing to shared repositories.

## Establish module publishing and distribution strategies

Your module distribution approach affects collaboration, version control, and the reliability of your infrastructure deployments across teams and projects.

1. **Use public registries for Microsoft-maintained and community modules.** Adopt modules from public registries when they meet your requirements and are maintained by reputable providers. For Bicep modules, use the public Bicep module registry (source code is available in GitHub). For Terraform modules, use the [HashiCorp Terraform Module Registry](https://registry.terraform.io/namespaces/Azure) that includes several Azure modules. [Azure Verified Modules](https://azure.github.io/Azure-Verified-Modules/overview/introduction/) provide tested, supported implementations for both Bicep and Terraform that align with Azure best practices. Verify the support statement and maintenance commitment from module providers before adopting external modules in production environments.

2. **Establish private registries for organization-specific modules.** Create private module repositories when you need custom configurations that align with your organizational requirements, compliance standards, or security policies. For Bicep modules, use [Azure Container Registry](/azure/container-registry/container-registry-modules-intro) to publish modules to a private registry, with CI/CD pipeline integration through GitHub Actions or Azure Pipelines. For Terraform modules, use Terraform Cloud Private Registry or Azure Container Registry. Implement proper access controls, versioning strategies, and approval processes for module updates to maintain quality and security standards.

3. **Use version control systems for direct module loading.** Load modules directly from version control tools like GitHub or Azure DevOps when you need full control over module source and distribution. This approach works for both Bicep and Terraform modules. For Bicep, you can reference modules directly from version control repositories. For Terraform, you can load private modules from various supported sources including GitHub, with flexibility for different version control systems and deployment scenarios.

4. **Implement version control and governance for module distribution.** Establish governance processes that require testing, security review, and approval before publishing new module versions. Document breaking changes and provide migration guidance when updating modules. Consider implementing automated testing and security scanning in your module publishing pipeline.

## Deploy infrastructure through automated pipelines

Automated deployment pipelines ensure consistent, repeatable deployments while providing visibility into changes and enabling rapid recovery from issues.

1. **Implement CI/CD pipelines for all infrastructure deployments.** Use [Azure DevOps](/azure/devops/pipelines/) or [GitHub Actions](/azure/azure-resource-manager/bicep/deploy-github-actions), or similar platforms to automate your IaC deployments. Pipelines should include linting, security scanning, testing, and approval gates before deploying to production environments. This automation reduces deployment errors, ensures consistent processes, and provides audit trails for compliance requirements.

2. **Establish environment promotion strategies with appropriate testing.** Deploy infrastructure changes through multiple environments (development, testing, staging, production) with increasing levels of validation and approval requirements. Consider [deployment stacks](/azure/azure-resource-manager/bicep/deployment-stacks) or Terraform state management to track resource lifecycle and enable safe updates. Implement automated testing that validates infrastructure configuration, security posture, and functionality before promoting to the next environment.

3. **Enable infrastructure drift detection and remediation.** Configure monitoring and alerting to detect when deployed infrastructure deviates from the defined IaC templates. Use tools like [Azure Policy](/azure/governance/policy/overview) to identify and remediate configuration drift automatically. Establish processes to investigate drift causes and update IaC templates to reflect legitimate changes while reverting unauthorized modifications.

4. **Understand your deployment scopes before deploying.** Azure supports multiple [deployment scopes](/azure/azure-resource-manager/templates/deploy-to-resource-group) including resource groups, subscriptions, management groups, and tenant levels. Review the [Azure management levels and hierarchy](../azure-setup-guide/organize-resources.md) to understand where your resources need to be deployed. Each IaC template must target the appropriate scope, and different tools have varying capabilities at each scope level. For example, tenant-level deployments require specific permissions and support different resource types than resource group deployments.
